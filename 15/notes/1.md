啥是标准函数？必须根据标准所定义的方式执行。

# 1. 错误报告
丫这段“提示”有点绕
只有当被调用的函数提示有错误发生时检查errno的值才有意义

# 2.终止执行

# 3.标准I/O函数库
ANSI：可移植性 和 完整性
增加不同函数

# 4.ANSI I/O概念

## 4.1 流

## 4.2 文件

## 4.3 标准I/O常量

EOF： 所选择的实际值比一个字符要多几位，是为了避免二进制值被错误的解释为EOF。

# 5. 

# 6. 打开流

# 7.关闭流
为什么关闭流成功与否需要检查？
也没说

# 8. 字符I/O
- getchar族函数负责
- 返回值是int，为了处理EOF
- 可以使用这些函数来读取二进制文件？“在二进制文件中，所有的字符都有可能出现”
- putchar族函数返回值是int，失败的话返回EOF

## 8.2 撤销
ungetc： 与写入到流的不同，与一个流相关联的外部存储并不受ungetc

# 9.未格式化的行I/O

fputs
- fputs 与 fgets的一个区别：没有缓冲区长度的参数。*传递给fputs缓冲区必包含一个字符串，以NUL结尾*
- fgets每次读取一整行时，fputs可一次写入一行的一部分，可以一次写入一整行、一次写入好几行。（就认NUL不认换行）
- 写入错误返回EOF，否则返回非负值

> 缓冲区长度必须大于等于2，因为有NUL噻。 

gets/puts的细微区别：
1. gets: 并不在缓冲区中存储结尾的换行符；没有缓冲区长度，多出来的字符将被写入到缓冲区后面的内存位置，破坏性。！！！
2. puts：写入一个字符串时，写入之后再加一个换行符。

# 10. 格式化的行I/O
scanf & printf： 其实作用对象是不仅限于行的。

- scanf:
- - 限定符 又提到可移植性的问题
- - 一些技巧

- printf:
- - sprintf: 缓冲区大小并不是一个参数，again，溢出时改写内存未知中的数据。加大缓冲区或者用**格式代码**中一个可选字段来限制。

*修改符的作用*

一些例子！
%g有点迷，可能规则有点复杂

# 11.二进制I/O
二进制是把数据写入到文件的最有效方法：避免了数值转换为字符串过程中所涉及的开销和精度损失。

函数


# 12 刷新和定位函数

fseek函数对于二进制和文本各有一些限制，文本只能从头开始定位，而且必须是ftell返回值。二进制可能不支持到达文件尾部。

原因： 文本的行尾文本映射，导致文本的字节数可能和程序写入的字节数不同。

三个副作用：
1. 行末指示字符被清除。
2. ungetc被丢弃。
3. 允许从写入模式切换到读取模式，或者回到打开的流以便更新。

# 13.改变缓冲方式

BUFSIZ 在 <stdio.h>中定义。

> 为一个流自行指定缓冲区可以防止I/O函数库为它动态分配一个缓冲区。也可以关闭缓冲。

FBI Warning: 注意的作为缓冲区数组的scope！！！

如果指定缓冲区大小，最好是BUFSIZ的整数倍，否则会需要一些额外的磁盘操作。

# 14.

# 15.

# 16.




