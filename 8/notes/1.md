# 1. 一维数组

# 1.1 数组名

> 数组名和指针的区别： 数组具有确定数量的元素， 指针只是一个标量值。编译器用数组名来记住这些属性。只有当数组名在表达式中使用时，编译器才会为它产生一个指针常量。

两种情况数组名并不用于表示指针常量
1. sizeof 数组长度
2. & 指向整个数组的指针

注意：数组名是常量（指针常量），不能被赋值
两个数组

# 1.2 下标引用

> c的下标引用和间接访问表达式是**一样**的！！！可互换。

> 下标检查开销多...

# 1.3 指针与下标

- 效率 数组中1次固定步数移动，与固定数字的乘法运算在编译时期完成。

# 1.4 指针的效率
？天哪，汇编分析，基本没明白

终级版本：寄存器变量+消除计数器：

奥义：编译时完成计算

# 1.5 指针与数组

# 1.6 作为函数参数的数组名

# 1.7 声明数组参数

# 1.8 初始化
- 静态： 程序开始执行之前。链接器完成。
- 自动：编译器没有办法对这些不确定的位置进行初始化。

> 需要权衡，每次进入函数前都要进行初始化是否合适。

# 1.9 不完整的初始化

# 1.10 自动计算数组长度

# 1.11 字符数组的初始化

```c
//以下两种方式一样
char message[] = {'H', 'e', 'l', 'l', 'o', 0};
char message[] = "Hello";
```

```c
char message1[] = "Hello"//字符数组
char *message2 = "Hello";//字符串常量
```

# 2. 多维数组

## 2.4 指向数组的指针

```c
//常见错误
int matrix[3][10], *mp = matrix;
//正确声明：p是指向matrix第一行的 指针
int (*p)[10] = matrix;

//等同的表达
int *pi = &matrix[0][0];
int *pi = matrix[0];

//注意：需要避免，因为指针运算时候根据空数组的长度进行调整，也就是0
int (*p)[] = matrix;
```

## 2.5 作为函数参数的多维数组

> 编译器必须知道第2个及以后各维的长度才能对各下标进行求值。因此在原型中必须声明这些维的长度。

指向整型的指针的指针和指向整型数组的指针并不是一回事。

## 2.6 初始化

## 2.7 数组长度自动计算

# 3. 指针数组
```c
//下标引用优先级高于间接访问，因此api是某种类型的数组。元素类型是指向整型的指针。
int *api[10];
```

字符串相关：指针数组和二维数组的取舍

> 只要有可能：函数的指针形参都应该声明为const
